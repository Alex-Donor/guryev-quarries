<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>–ì—É—Ä—å–µ–≤—Å–∫–∏–µ –∫–∞–º–µ–Ω–æ–ª–æ–º–Ω–∏ ‚Äî –ú–∞—Ä—à—Ä—É—Ç–∏–∑–∞—Ü–∏—è</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: Calibri, Arial, sans-serif;
    }
    #map {
      width: 100%;
      height: 100vh;
      cursor: default;
    }

    /* –ö–Ω–æ–ø–∫–∞ –º–µ–Ω—é */
    #menu-button {
      position: absolute;
      top: 10px;
      left: 10px;
      width: 40px;
      height: 40px;
      background: white;
      border: 2px solid #ccc;
      border-radius: 6px;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      cursor: pointer;
      z-index: 1001;
      box-shadow: 0 0 8px rgba(0,0,0,0.3);
    }
    #menu-button span {
      display: block;
      width: 4px;
      height: 4px;
      background: #333;
      border-radius: 50%;
      margin: 1px 0;
    }

    /* Zoom control */
    #zoom-control {
      position: absolute;
      top: 16px;
      left: 80px;
      display: flex;
      gap: 4px;
      z-index: 1000;
    }
    .zoom-btn {
      width: 30px;
      height: 30px;
      background: white;
      border: 2px solid rgba(0,0,0,0.2);
      border-radius: 4px;
      font-weight: bold;
      font-size: 18px;
      cursor: pointer;
      display: flex;
      justify-content: center;
      align-items: center;
      box-shadow: 0 1px 5px rgba(0,0,0,0.4);
    }
    .zoom-btn:hover {
      background: #f0f0f0;
    }

    /* –ê–≤—Ç–æ—Ä—Å–∫–∏–µ –ø—Ä–∞–≤–∞ */
    #copyright {
      position: absolute;
      top: 18px;
      left: 160px;
      z-index: 1000;
      font-size: 13px;
    }
    #copyright span {
      display: inline-block;
      color: #0066cc; /* –°–∏–Ω–∏–π —Ç–µ–∫—Å—Ç */
      font-weight: bold;
      border: none;
      background: transparent;
      padding: 0;
      text-shadow:
        -1px -1px 0 red,
         1px -1px 0 red,
        -1px  1px 0 red,
         1px  1px 0 red;
    }

    /* –í—ã–ø–∞–¥–∞—é—â–µ–µ –º–µ–Ω—é */
    #dropdown-menu {
      display: none;
      position: absolute;
      top: 55px;
      left: 10px;
      background: #e8e8e8;
      padding: 16px 2px;
      border-radius: 8px;
      box-shadow: 0 0 12px rgba(0,0,0,0.5);
      z-index: 1000;
      width: fit-content;
      font-size: 14px;
      font-family: Calibri, Arial, sans-serif;
    }
    #dropdown-menu.active {
      display: block;
    }

    .menu-section {
      margin-bottom: 12px;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .menu-label {
      display: block;
      font-weight: bold;
      color: #222;
      margin-bottom: 6px;
      text-shadow: 0 0 4px white, 0 0 6px white;
      font-family: Calibri, Arial, sans-serif;
    }

    input[type="text"],
    select {
      width: auto;
      min-width: 0;
      padding: 8px;
      font-size: 14px;
      border: 1px solid #999;
      border-radius: 4px;
      box-sizing: border-box;
      background: white;
      font-family: Calibri, Arial, sans-serif;
    }

    .menu-btn {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-weight: bold;
      font-size: 14px;
      background: #dcdcdc;
      border: 1px solid #aaa;
      border-radius: 4px;
      cursor: pointer;
      padding: 10px 12px;
      white-space: nowrap;
      font-family: Calibri, Arial, sans-serif;
    }
    .menu-btn:hover {
      background: #ccc;
    }

    /* –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä –¥–ª—è –∫–Ω–æ–ø–∫–∏ –∑–∞–≥—Ä—É–∑–∫–∏ –º–∞—Ä—à—Ä—É—Ç–∞ */
    .load-route-container {
      display: flex;
      gap: 6px;
      align-items: center;
      width: fit-content;
    }

    /* –ö–Ω–æ–ø–∫–∞ "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –º–∞—Ä—à—Ä—É—Ç" ‚Äî –∫–æ–º–ø–∞–∫—Ç–Ω–∞—è */
    #load-route {
      width: auto;
      max-width: max-content;
      padding: 10px 12px;
      white-space: nowrap;
    }

    #file-input {
      display: none;
    }

    /* –°—Ç–∞—Ç—É—Å–Ω–∞—è –ø–∞–Ω–µ–ª—å */
    #status {
      position: absolute;
      bottom: 12px;
      left: 12px;
      background: #e8e8e8;
      padding: 8px 12px;
      border-radius: 4px;
      font-size: 14px;
      color: #222;
      z-index: 1000;
      max-width: 300px;
      line-height: 1.4;
      box-shadow: 0 1px 4px rgba(0,0,0,0.25);
      font-family: Calibri, Arial, sans-serif;
    }

    .route-distance {
      color: red;
      font-weight: bold;
    }

    /* –ö–Ω–æ–ø–∫–∞ –æ—á–∏—Å—Ç–∫–∏ */
    #clear-route-btn {
      position: absolute;
      bottom: 70px;
      left: 12px;
      padding: 8px 12px;
      font-size: 14px;
      background: #dcdcdc;
      border: 1px solid #aaa;
      border-radius: 4px;
      cursor: pointer;
      z-index: 1000;
      box-shadow: 0 1px 4px rgba(0,0,0,0.25);
      font-weight: bold;
      font-family: Calibri, Arial, sans-serif;
    }
    #clear-route-btn:hover {
      background: #ccc;
    }

    #map.clickable {
      cursor: crosshair;
    }
    .leaflet-control-attribution {
      display: none !important;
    }

    #loading-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      z-index: 2000;
      justify-content: center;
      align-items: center;
    }
    #loading-modal {
      background: white;
      padding: 20px 30px;
      border-radius: 10px;
      font-size: 18px;
      font-weight: bold;
      text-align: center;
      box-shadow: 0 4px 20px rgba(0,0,0,0.6);
      font-family: Calibri, Arial, sans-serif;
    }
  </style>
</head>
<body>
<div id="menu-button">
  <span></span>
  <span></span>
  <span></span>
</div>

<div id="zoom-control">
  <div class="zoom-btn" id="zoom-in">+</div>
  <div class="zoom-btn" id="zoom-out">‚àí</div>
</div>

<div id="copyright">
  <span>¬© by Alex Donor</span>
</div>

<div id="dropdown-menu">
  <div class="menu-section">
    <span class="menu-label">–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ä—Ç—É:</span>
    <select id="background-select">
      <option value="byaki.png">–ë–∞–∑–æ–≤–∞—è –∫–∞—Ä—Ç–∞ ‚ñº</option>
      <option value="map2.png">–ö–∞—Ä—Ç–∞ —Å –∑–∞–ª–∏–≤–∫–æ–π</option>
    </select>
  </div>

  <div class="menu-section">
    <span class="menu-label">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –º–∞—Ä—à—Ä—É—Ç:</span>
    <div style="display: flex; gap: 6px; align-items: center;">
      <input type="text" id="route-name" placeholder="–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ" value="–ú–æ–π –º–∞—Ä—à—Ä—É—Ç">
      <button class="menu-btn" id="save-route">üíæ</button>
    </div>
  </div>

  <div class="menu-section">
    <span class="menu-label"> –ó–∞–≥—Ä—É–∑–∏—Ç—å –º–∞—Ä—à—Ä—É—Ç:</span>
    <div class="load-route-container">
      <button class="menu-btn" id="load-route">üìÅ –í—ã–±–µ—Ä–∏—Ç–µ —Ñ–∞–π–ª...</button>
      <input type="file" id="file-input" accept=".json">
    </div>
  </div>
</div>

<button id="clear-route-btn">üóëÔ∏è –û—á–∏—Å—Ç–∏—Ç—å –º–∞—Ä—à—Ä—É—Ç</button>

<div id="map"></div>
<div id="status">–ó–∞–≥—Ä—É–∑–∫–∞ –∫–∞—Ä—Ç—ã...</div>

<div id="loading-overlay">
  <div id="loading-modal">–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–¥–æ–∂–¥–∏—Ç–µ‚Ä¶<br>–ú–∞—Ä—à—Ä—É—Ç —Å—Ç—Ä–æ–∏—Ç—Å—è</div>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
  const map = L.map('map', {
    crs: L.CRS.Simple,
    minZoom: 0.05,
    maxZoom: 4,
    zoomControl: false
  });

  document.getElementById('zoom-in').addEventListener('click', () => {
    if (map.getZoom() < map.getMaxZoom()) map.zoomIn();
  });
  document.getElementById('zoom-out').addEventListener('click', () => {
    if (map.getZoom() > map.getMinZoom()) map.zoomOut();
  });

  function distToSegment(p, v, w) {
    const dx = w[0] - v[0];
    const dy = w[1] - v[1];
    const l2 = dx * dx + dy * dy;
    if (l2 === 0) return Math.hypot(p[0] - v[0], p[1] - v[1]);
    let t = ((p[0] - v[0]) * dx + (p[1] - v[1]) * dy) / l2;
    t = Math.max(0, Math.min(1, t));
    return Math.hypot(p[0] - (v[0] + t * dx), p[1] - (v[1] + t * dy));
  }

  let segments = [];
  let graph = {};
  let selectedPoints = [];
  let pointMarkers = [];
  let routeLayer = null;
  let currentImageOverlay = null;
  let mapBounds = null;
  let menuOpen = false;

  const CURSOR_TOLERANCE_PX = 1;

  function handleMouseMove(e) {
    const container = map.getContainer();
    container.classList.remove('clickable');
    if (segments.length === 0) return;

    const mouse = [e.latlng.lng, e.latlng.lat];
    const p1 = map.containerPointToLayerPoint([0, 0]);
    const p2 = map.containerPointToLayerPoint([CURSOR_TOLERANCE_PX, 0]);
    const tolerance = Math.abs(p2.x - p1.x);

    for (let i = 0; i < segments.length; i++) {
      if (distToSegment(mouse, segments[i][0], segments[i][1]) <= tolerance) {
        container.classList.add('clickable');
        return;
      }
    }
  }

  map.on('mousemove', handleMouseMove);

  function clearRoute() {
    if (routeLayer) map.removeLayer(routeLayer);
    pointMarkers.forEach(marker => map.removeLayer(marker));
    routeLayer = null;
    selectedPoints = [];
    pointMarkers = [];
    document.getElementById('status').textContent = '–ö–ª–∏–∫–Ω–∏—Ç–µ –Ω–∞ —Å—Ö–µ–º—É –¥–ª—è –≤—ã–±–æ—Ä–∞ —Ç–æ—á–µ–∫ –º–∞—Ä—à—Ä—É—Ç–∞';
    map.getContainer().classList.remove('clickable');
  }

  function dijkstra(graph, start, end) {
    if (!graph[start] || !graph[end]) return null;
    const dist = {};
    const prev = {};
    const unvisited = new Set();

    for (const node in graph) {
      dist[node] = node === start ? 0 : Infinity;
      unvisited.add(node);
    }

    while (unvisited.size > 0) {
      let current = null;
      let minDist = Infinity;
      for (const node of unvisited) {
        if (dist[node] < minDist) {
          minDist = dist[node];
          current = node;
        }
      }

      if (current === end || minDist === Infinity) break;
      unvisited.delete(current);

      for (const neighbor in graph[current]) {
        if (unvisited.has(neighbor)) {
          const alt = dist[current] + graph[current][neighbor];
          if (alt < dist[neighbor]) {
            dist[neighbor] = alt;
            prev[neighbor] = current;
          }
        }
      }
    }

    if (dist[end] === Infinity) return null;
    const path = [];
    let u = end;
    while (u !== undefined) {
      path.unshift(u.split(',').map(Number));
      if (u === start) break;
      u = prev[u];
    }
    return path.length > 1 ? path : null;
  }

  function buildFullRoute() {
    if (selectedPoints.length < 2) return;

    document.getElementById('loading-overlay').style.display = 'flex';
    setTimeout(() => {
      if (routeLayer) map.removeLayer(routeLayer);
      routeLayer = null;

      const fullPath = [];
      let totalDistance = 0;
      let valid = true;

      for (let i = 0; i < selectedPoints.length - 1; i++) {
        const startKey = selectedPoints[i].join(',');
        const endKey = selectedPoints[i + 1].join(',');
        const segmentPath = dijkstra(graph, startKey, endKey);
        if (!segmentPath) {
          valid = false;
          break;
        }
        if (i === 0) {
          fullPath.push(...segmentPath);
        } else {
          fullPath.push(...segmentPath.slice(1));
        }
        for (let j = 1; j < segmentPath.length; j++) {
          const a = segmentPath[j - 1];
          const b = segmentPath[j];
          totalDistance += Math.hypot(a[0] - b[0], a[1] - b[1]);
        }
      }

      document.getElementById('loading-overlay').style.display = 'none';

      if (!valid) {
        document.getElementById('status').textContent = '–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ—Å—Ç—Ä–æ–∏—Ç—å –º–∞—Ä—à—Ä—É—Ç';
        return;
      }

      routeLayer = L.polyline(fullPath.map(p => [p[1], p[0]]), {
        color: 'red',
        weight: 4
      }).addTo(map);

      document.getElementById('status').innerHTML =
        `–ú–∞—Ä—à—Ä—É—Ç: <span class="route-distance">${totalDistance.toFixed(1)} –º</span> (—Ç–æ—á–µ–∫: ${selectedPoints.length})`;
    }, 10);
  }

  map.on('click', function(e) {
    if (menuOpen || segments.length === 0) return;

    const click = [e.latlng.lng, e.latlng.lat];
    const TOLERANCE = 4;

    let nearest = null;
    let minDist = Infinity;
    for (const node in graph) {
      const [x, y] = node.split(',').map(Number);
      const d = Math.hypot(x - click[0], y - click[1]);
      if (d < minDist) {
        minDist = d;
        nearest = [x, y];
      }
    }

    if (!nearest || minDist > TOLERANCE) {
      document.getElementById('status').textContent = '–ö–ª–∏–∫ —Å–ª–∏—à–∫–æ–º –¥–∞–ª–µ–∫–æ –æ—Ç —Ç–æ–Ω–Ω–µ–ª–µ–π';
      return;
    }

    let color = 'purple';
    if (selectedPoints.length === 0) color = 'green';
    else if (selectedPoints.length === 1) color = 'blue';

    selectedPoints.push(nearest);
    const marker = L.circle([nearest[1], nearest[0]], {
      radius: 1,
      color: color,
      weight: 2,
      fillOpacity: 1
    }).addTo(map);
    pointMarkers.push(marker);

    if (selectedPoints.length === 1) {
      document.getElementById('status').textContent = '–í—ã–±–µ—Ä–∏—Ç–µ —Å–ª–µ–¥—É—é—â—É—é —Ç–æ—á–∫—É –º–∞—Ä—à—Ä—É—Ç–∞';
    } else {
      buildFullRoute();
    }
  });

  const menuButton = document.getElementById('menu-button');
  const dropdownMenu = document.getElementById('dropdown-menu');

  menuButton.addEventListener('click', (e) => {
    e.stopPropagation();
    menuOpen = !menuOpen;
    dropdownMenu.classList.toggle('active', menuOpen);
  });

  document.addEventListener('click', () => {
    if (menuOpen) {
      menuOpen = false;
      dropdownMenu.classList.remove('active');
    }
  });

  dropdownMenu.addEventListener('click', (e) => {
    e.stopPropagation();
  });

  document.getElementById('clear-route-btn').addEventListener('click', clearRoute);

  document.getElementById('background-select').addEventListener('change', function(e) {
    if (mapBounds) {
      if (currentImageOverlay) map.removeLayer(currentImageOverlay);
      currentImageOverlay = L.imageOverlay(e.target.value, mapBounds, { opacity: 1 }).addTo(map);
    }
  });

  document.getElementById('save-route').addEventListener('click', () => {
    if (selectedPoints.length < 2) {
      alert('–ù–µ—Ç –º–∞—Ä—à—Ä—É—Ç–∞ –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è (–Ω—É–∂–Ω–æ –º–∏–Ω–∏–º—É–º 2 —Ç–æ—á–∫–∏)');
      return;
    }

    const routeName = document.getElementById('route-name').value.trim() || '–ú–æ–π –º–∞—Ä—à—Ä—É—Ç';
    const data = { version: 1, name: routeName, points: selectedPoints };
    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json;charset=utf-8' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;

    const safeName = routeName
      .replace(/[^\w–∞-—è–ê-–Ø—ë–Å\s.-]/g, '_')
      .replace(/\s+/g, '_')
      .replace(/_{2,}/g, '_')
      .trim() || '–ú–∞—Ä—à—Ä—É—Ç';
    a.download = safeName + '.json';

    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);

    document.getElementById('route-name').value = '–ú–æ–π –º–∞—Ä—à—Ä—É—Ç';

    menuOpen = false;
    dropdownMenu.classList.remove('active');
  });

  document.getElementById('load-route').addEventListener('click', () => {
    document.getElementById('file-input').click();
  });

  document.getElementById('file-input').addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (event) => {
      try {
        const data = JSON.parse(event.target.result);
        if (!data.points || !Array.isArray(data.points) || data.points.length < 2) {
          throw new Error('–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç —Ñ–∞–π–ª–∞');
        }

        clearRoute();
        selectedPoints = data.points.map(pt => [...pt]);
        selectedPoints.forEach((pt, idx) => {
          let color = 'purple';
          if (idx === 0) color = 'green';
          else if (idx === selectedPoints.length - 1) color = 'blue';

          const marker = L.circle([pt[1], pt[0]], {
            radius: 1,
            color: color,
            weight: 2,
            fillOpacity: 1
          }).addTo(map);
          pointMarkers.push(marker);
        });

        buildFullRoute();
        if (data.name) {
          document.getElementById('route-name').value = data.name;
        }
        menuOpen = false;
        dropdownMenu.classList.remove('active');
      } catch (err) {
        alert('–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –º–∞—Ä—à—Ä—É—Ç–∞: ' + err.message);
      } finally {
        e.target.value = '';
      }
    };
    reader.readAsText(file);
  });

  fetch('tunnels_json.geojson')
    .then(res => {
      if (!res.ok) throw new Error('–§–∞–π–ª tunnels_json.geojson –Ω–µ –Ω–∞–π–¥–µ–Ω');
      return res.json();
    })
    .then(data => {
      const allCoords = [];
      segments = [];
      graph = {};

      data.features.forEach(f => {
        if (!f.geometry) return;
        let lines = [];
        if (f.geometry.type === 'LineString') lines = [f.geometry.coordinates];
        else if (f.geometry.type === 'MultiLineString') lines = f.geometry.coordinates;
        else return;

        lines.forEach(coords => {
          if (coords.length < 2) return;
          coords.forEach(pt => allCoords.push(pt));
          for (let i = 0; i < coords.length - 1; i++) {
            const a = coords[i];
            const b = coords[i + 1];
            segments.push([a, b]);

            const keyA = a.join(',');
            const keyB = b.join(',');
            const len = Math.hypot(a[0] - b[0], a[1] - b[1]);

            if (!graph[keyA]) graph[keyA] = {};
            if (!graph[keyB]) graph[keyB] = {};

            graph[keyA][keyB] = len;
            graph[keyB][keyA] = len;
          }
        });
      });

      if (allCoords.length === 0) {
        document.getElementById('status').textContent = 'GeoJSON –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç';
        return;
      }

      const xs = allCoords.map(c => c[0]);
      const ys = allCoords.map(c => c[1]);
      mapBounds = [
        [Math.min(...ys), Math.min(...xs)],
        [Math.max(...ys), Math.max(...xs)]
      ];
      map.fitBounds(mapBounds);

      currentImageOverlay = L.imageOverlay('byaki.png', mapBounds, { opacity: 1 }).addTo(map);
      document.getElementById('status').textContent = '–ö–ª–∏–∫–Ω–∏—Ç–µ –Ω–∞ —Å—Ö–µ–º—É –¥–ª—è –≤—ã–±–æ—Ä–∞ —Ç–æ—á–µ–∫ –º–∞—Ä—à—Ä—É—Ç–∞';
    })
    .catch(err => {
      console.error("–û—à–∏–±–∫–∞:", err);
      document.getElementById('status').textContent = '–û—à–∏–±–∫–∞: ' + err.message;
    });
</script>
</body>
</html>
